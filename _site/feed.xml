<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>yuanmie</title>
    <description>疯狂的学习.</description>
    <link>http://192.168.11.32:4000/</link>
    <atom:link href="http://192.168.11.32:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sat, 27 Jun 2020 22:52:24 +0800</pubDate>
    <lastBuildDate>Sat, 27 Jun 2020 22:52:24 +0800</lastBuildDate>
    <generator>Jekyll v4.1.1</generator>
    
      <item>
        <title>高可用解决方案</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;“高可用—第1篇. ”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;高可用&quot;&gt;高可用&lt;/h1&gt;

</description>
        <pubDate>Sat, 27 Jun 2020 00:00:00 +0800</pubDate>
        <link>http://192.168.11.32:4000/linux/2020/06/27/%E9%AB%98%E5%8F%AF%E7%94%A8/</link>
        <guid isPermaLink="true">http://192.168.11.32:4000/linux/2020/06/27/%E9%AB%98%E5%8F%AF%E7%94%A8/</guid>
        
        <category>高可用</category>
        
        
        <category>Linux</category>
        
      </item>
    
      <item>
        <title>zabbix</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;“zabbix—第1篇. ”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;zabbix，是什么。&lt;/p&gt;

&lt;h1 id=&quot;zabbix&quot;&gt;zabbix&lt;/h1&gt;

</description>
        <pubDate>Sat, 27 Jun 2020 00:00:00 +0800</pubDate>
        <link>http://192.168.11.32:4000/linux/2020/06/27/zabbix/</link>
        <guid isPermaLink="true">http://192.168.11.32:4000/linux/2020/06/27/zabbix/</guid>
        
        <category>zabbix</category>
        
        
        <category>Linux</category>
        
      </item>
    
      <item>
        <title>nginx</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;nginx—第1篇. ”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;nginx，搞懂反向代理和负载均衡！&lt;/p&gt;

&lt;h1 id=&quot;反向代理&quot;&gt;反向代理&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;反向代理怎么做？具体如何实现？&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;代理的分类&quot;&gt;代理的分类&lt;/h2&gt;

&lt;p&gt;有反向代理就有正向代理。&lt;/p&gt;

&lt;h3 id=&quot;概念&quot;&gt;概念&lt;/h3&gt;
&lt;p&gt;正向代理：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;正向代理，架设在客户机与目标主机之间，只用于代理内部网络对Internet的连接请求，客户机必须指定代理服务器,并将本来要直接发送到Web服务器上的http请求发送到代理服务器中。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;反向代理：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;反向代理服务器架设在服务器端，通过缓冲经常被请求的页面来缓解服务器的工作量，将客户机请求转发给内部网络上的目标服务器；并将从服务器上得到的结果返回给Internet上请求连接的客户端（理解+背），此时代理服务器与目标主机一起对外表现为一个服务器。 ### 区别 反向代理和正向代理的区别就是：

正向代理代理客户端，反向代理代理服务器。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;作用&quot;&gt;作用&lt;/h3&gt;
&lt;p&gt;正向代理：类似一个跳板机，代理访问外部资源。（在客户机和目标主机之间）&lt;/p&gt;

&lt;p&gt;作用：&lt;/p&gt;

&lt;p&gt;（1）访问原来无法访问的资源，如google（做VPN）&lt;/p&gt;

&lt;p&gt;（2）可以做缓存，加速访问资源&lt;/p&gt;

&lt;p&gt;（3）对客户端访问授权，上网进行认证&lt;/p&gt;

&lt;p&gt;（4）代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息&lt;/p&gt;

&lt;p&gt;反向代理：以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端。（架设在服务器端）&lt;/p&gt;

&lt;p&gt;作用：&lt;/p&gt;

&lt;p&gt;（1）保证内网的安全，阻止web攻击，大型网站，通常将反向代理作为公网访问地址，Web服务器是内网&lt;/p&gt;

&lt;p&gt;（2）负载均衡，通过反向代理服务器来优化网站的负载&lt;/p&gt;

&lt;p&gt;（3）通过缓存静态资源，加速Web请求。&lt;/p&gt;

&lt;h3 id=&quot;透明代理&quot;&gt;透明代理&lt;/h3&gt;

&lt;p&gt;面试被问到了。&lt;/p&gt;

&lt;p&gt;它主要指内网主机需要访问外网主机时，不需要做任何设置，完全意识不到防火墙的存在，而完成内外网的通信。但其基本原理是防火墙代替内部网络主机完成与外网主机通信，然后把结果传回给内网主机，在这个过程中，无论内网主机还是外网主机都意识不到它们其实是在和防火墙通信。而从外网只能看到防火墙，这就隐藏了内网网络，提高了安全性。&lt;/p&gt;

&lt;h2 id=&quot;nginx反向代理的例子&quot;&gt;nginx反向代理的例子&lt;/h2&gt;

&lt;h1 id=&quot;负载均衡&quot;&gt;负载均衡&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;负载均衡怎么做？具体怎么实现？&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;一句话：nginx会给你分配服务器压力小的去访问。&lt;/p&gt;

&lt;p&gt;如何去实现负载均衡？&lt;a href=&quot;http://nginx.org/en/docs/http/load_balancing.html&quot;&gt;官网&lt;/a&gt;给了几种方法。&lt;/p&gt;

&lt;h2 id=&quot;轮循默认&quot;&gt;轮循（默认）&lt;/h2&gt;

&lt;p&gt;Nginx根据请求次数，将每个请求均匀分配到每台服务器&lt;/p&gt;

&lt;h2 id=&quot;最少连接&quot;&gt;最少连接&lt;/h2&gt;

&lt;p&gt;将请求分配给连接数最少的服务器。Nginx会统计哪些服务器的连接数最少。&lt;/p&gt;

&lt;h2 id=&quot;ip-hash&quot;&gt;IP Hash&lt;/h2&gt;

&lt;p&gt;绑定处理请求的服务器。第一次请求时，根据该客户端的IP算出一个HASH值，将请求分配到集群中的某一台服务器上。后面该客户端的所有请求，都将通过HASH算法，找到之前处理这台客户端请求的服务器，然后将请求交给它来处理。（如果客户已经访问了某个服务器，当用户再次访问时，会将该请求通过哈希算法，自动定位到该服务器。）&lt;/p&gt;

&lt;h2 id=&quot;指定权重weight&quot;&gt;指定权重（weight）&lt;/h2&gt;

&lt;p&gt;指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。&lt;/p&gt;
</description>
        <pubDate>Sat, 27 Jun 2020 00:00:00 +0800</pubDate>
        <link>http://192.168.11.32:4000/linux/2020/06/27/nginx/</link>
        <guid isPermaLink="true">http://192.168.11.32:4000/linux/2020/06/27/nginx/</guid>
        
        <category>nginx</category>
        
        
        <category>Linux</category>
        
      </item>
    
      <item>
        <title>mysql高可用</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;高可用之mysql—第2篇. ”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;mysql高可用是如何实现的？&lt;/p&gt;

&lt;p&gt;在mysql高可用内，你遇到什么问题？如何解决？&lt;/p&gt;

</description>
        <pubDate>Sat, 27 Jun 2020 00:00:00 +0800</pubDate>
        <link>http://192.168.11.32:4000/linux/2020/06/27/mysql%E9%AB%98%E5%8F%AF%E7%94%A8/</link>
        <guid isPermaLink="true">http://192.168.11.32:4000/linux/2020/06/27/mysql%E9%AB%98%E5%8F%AF%E7%94%A8/</guid>
        
        <category>高可用</category>
        
        
        <category>Linux</category>
        
      </item>
    
      <item>
        <title>jenkins</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;jenkins—第1篇. ”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;jenkins&lt;/p&gt;

&lt;h1 id=&quot;jenkins&quot;&gt;jenkins&lt;/h1&gt;

</description>
        <pubDate>Sat, 27 Jun 2020 00:00:00 +0800</pubDate>
        <link>http://192.168.11.32:4000/linux/2020/06/27/jenkins/</link>
        <guid isPermaLink="true">http://192.168.11.32:4000/linux/2020/06/27/jenkins/</guid>
        
        <category>jenkins</category>
        
        
        <category>Linux</category>
        
      </item>
    
      <item>
        <title>docker入门</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;“docker—第1篇. ”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;docker&quot;&gt;docker&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;images&lt;/code&gt;    List images                                   # 列出系统当前镜像&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ps&lt;/code&gt;        List containers                               # 列出容器列表&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;info&lt;/code&gt;      Display system-wide information               # 显示系统相关信息&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;inspect&lt;/code&gt;   Return low-level information on a container   # 查看容器详细信息&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kill&lt;/code&gt;      Kill a running container                      # kill 指定 docker 容器&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;load&lt;/code&gt;      Load an image from a tar archive              # 从一个 tar 包中加载一个镜像[对应 save]&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;save&lt;/code&gt;      Save an image to a tar archive                # 保存一个镜像为一个 tar 包[对应 load]&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;login&lt;/code&gt;     Register or Login to the docker registry server &lt;br /&gt;
              # 注册或者登陆一个 docker 源服务器&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tag&lt;/code&gt;       Tag an image into a repository                # 给源中镜像打标签&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pull&lt;/code&gt;      Pull an image or a repository from the docker registry server
              # 从docker镜像源服务器拉取指定镜像或者库镜像&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;push&lt;/code&gt;      Push an image or a repository to the docker registry server
              # 推送指定镜像或者库镜像至docker源服务器&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rm&lt;/code&gt;        Remove one or more containers                 # 移除一个或者多个容器&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rmi&lt;/code&gt;       Remove one or more images               &lt;br /&gt;
              # 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;log&lt;/code&gt;       Fetch the logs of a container                 # 输出当前容器日志信息&lt;/p&gt;

&lt;p&gt;例如：查看指定时间后的日志，只显示最后100行：
docker logs -f -t –since=”2020-06-27” –tail=100 CONTAINER_ID&lt;/p&gt;

&lt;p&gt;查看最近30分钟的日志：docker logs –since 30m CONTAINER_ID&lt;/p&gt;

&lt;p&gt;查看某时间之后的日志：logs -t –since=”2020-06-27T13:23:37” CONTAINER_ID&lt;/p&gt;

&lt;p&gt;查看某时间段日志：docker logs -t –since=”2020-06-26T13:23:37” –until “2020-06-27T12:23:37” CONTAINER_ID&lt;/p&gt;
</description>
        <pubDate>Sat, 27 Jun 2020 00:00:00 +0800</pubDate>
        <link>http://192.168.11.32:4000/linux/2020/06/27/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</link>
        <guid isPermaLink="true">http://192.168.11.32:4000/linux/2020/06/27/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</guid>
        
        <category>docker</category>
        
        
        <category>Linux</category>
        
      </item>
    
      <item>
        <title>docker累积</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;“docker—第2篇. ”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;docker的一些累积，持续更新。&lt;/p&gt;

&lt;h1 id=&quot;docker的安装&quot;&gt;docker的安装&lt;/h1&gt;

&lt;p&gt;安装方法有很多种，一种简单的方法：&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl &lt;span class=&quot;nt&quot;&gt;-fsSL&lt;/span&gt; https://get.docker.com | bash &lt;span class=&quot;nt&quot;&gt;-s&lt;/span&gt; docker &lt;span class=&quot;nt&quot;&gt;--mirror&lt;/span&gt; Aliyun。快速！
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h1 id=&quot;docker的默认&quot;&gt;docker的默认&lt;/h1&gt;

&lt;p&gt;docker有哪些默认的配置？记性不好了，记录记录，以便忘记的时候拿来看。&lt;/p&gt;

&lt;h2 id=&quot;docker默认存储位置&quot;&gt;docker默认存储位置&lt;/h2&gt;
&lt;p&gt;Docker默认存储位置在/var/lib/docker&lt;/p&gt;

&lt;h2 id=&quot;docker默认配置文件&quot;&gt;docker默认配置文件&lt;/h2&gt;
&lt;p&gt;ubuntu 中的位置是：/etc/default/docker&lt;/p&gt;

&lt;p&gt;centos 中的位置是：/etc/sysconfig/docker&lt;/p&gt;

&lt;h1 id=&quot;docker-compose&quot;&gt;docker compose&lt;/h1&gt;
</description>
        <pubDate>Sat, 27 Jun 2020 00:00:00 +0800</pubDate>
        <link>http://192.168.11.32:4000/linux/2020/06/27/dockerknowledge/</link>
        <guid isPermaLink="true">http://192.168.11.32:4000/linux/2020/06/27/dockerknowledge/</guid>
        
        <category>docker</category>
        
        
        <category>Linux</category>
        
      </item>
    
      <item>
        <title>ELK</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;“ELK—第1篇. ”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;ELK，是什么。&lt;/p&gt;

&lt;h1 id=&quot;elk&quot;&gt;ELK&lt;/h1&gt;

</description>
        <pubDate>Sat, 27 Jun 2020 00:00:00 +0800</pubDate>
        <link>http://192.168.11.32:4000/linux/2020/06/27/ELK/</link>
        <guid isPermaLink="true">http://192.168.11.32:4000/linux/2020/06/27/ELK/</guid>
        
        <category>ELK</category>
        
        
        <category>Linux</category>
        
      </item>
    
      <item>
        <title>jekyll之_posts</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;“jekyll—第2篇. ”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;首先感谢大佬&lt;a href=&quot;https://github.com/Huxpro/huxpro.github.io&quot;&gt;Huxpro&lt;/a&gt;做的模板，非常喜欢，风格也简约，blog的管理也非常方便。&lt;/p&gt;

&lt;p&gt;先知道安装，可以参考我的另一篇，把坑都填好了。运行起来之后，在看jekyll的目录结构，搞清楚每一个文档是干什么的。&lt;/p&gt;

&lt;h2 id=&quot;_posts文件&quot;&gt;_posts文件&lt;/h2&gt;

&lt;p&gt;这里放的就是你的文章了。文件格式很重要，必须符合：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;YEAR-MONTH-DAY-TITLE.MARKUP&lt;/code&gt;。The permalinks可以在文章中自己定制，但是数据和标记语言都是根据文件名来确定的。&lt;/p&gt;

&lt;h2 id=&quot;内容格式及修饰&quot;&gt;内容格式及修饰&lt;/h2&gt;

&lt;p&gt;分为2部分，yaml头文件和内容&lt;/p&gt;

&lt;p&gt;1.yaml头文件的格式，这个比较简单&lt;/p&gt;

&lt;p&gt;2.具体内容&lt;/p&gt;

&lt;p&gt;拿一篇文章来说，举个例子体现出用了什么东西。&lt;/p&gt;

&lt;p&gt;最喜欢的一部修真小说，从初中接触到大学毕业一直看，看了7遍，可以说里面的每一个场景都记得，就拿里面的一些东西来举例，顺便也做个例子。&lt;/p&gt;

&lt;p&gt;标题格式：### 内容&lt;/p&gt;

&lt;h3 id=&quot;隔一行和不隔一行的区别&quot;&gt;隔一行和不隔一行的区别：&lt;/h3&gt;

&lt;p&gt;玉符现，天地乱，虚无出，七界哭。逆天子，万灭徒，相逢日，七界无。&lt;/p&gt;

&lt;p&gt;夜月斩，夜月斩，太玄山上，黄河之畔。得之无意间，几许回忆在心田。
太玄山，天地间，修真几许为神仙？少年心，贪尘缘，狂剑纵横为红颜！&lt;/p&gt;

&lt;h3 id=&quot;链接格式&quot;&gt;链接格式&lt;/h3&gt;

&lt;p&gt;内容[]+()链接，在英文键盘下输入&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://baike.baidu.com/item/%E4%B8%83%E7%95%8C%E4%BC%A0%E8%AF%B4%E6%AD%A3%E4%BC%A0&quot;&gt;七界传说-百度百科&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;列表格式&quot;&gt;列表格式&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;述不清，道不明，世间最烦是感情！&lt;/li&gt;
  &lt;li&gt;见着怨，不见念，最难割舍最难断，是缘是孽，如何分辨？&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;字体格式&quot;&gt;字体格式&lt;/h3&gt;

&lt;p&gt;字体加颜色：
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;百世轮回，千世转变，沧海桑田，我心不变。&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;字体加粗：
&lt;strong&gt;如此星辰如此月，结伴携手月下行。&lt;/strong&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 25 Jun 2020 18:16:00 +0800</pubDate>
        <link>http://192.168.11.32:4000/2020/06/25/jekyll%E4%B9%8Bpost/</link>
        <guid isPermaLink="true">http://192.168.11.32:4000/2020/06/25/jekyll%E4%B9%8Bpost/</guid>
        
        <category>jekyll</category>
        
        
      </item>
    
      <item>
        <title>k8s一些思考</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;“k8s—第3篇. ”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;记录k8s的问题&lt;/p&gt;

&lt;h1 id=&quot;证书&quot;&gt;证书&lt;/h1&gt;
&lt;p&gt;一个k8s集群，最少有6套证书。&lt;/p&gt;

&lt;p&gt;ca根证书，etcd，client，apiserver，kubelet，kube-proxy&lt;/p&gt;

&lt;p&gt;证书签发插件有：cfssl，openssl等等&lt;/p&gt;

&lt;h1 id=&quot;pod的探针&quot;&gt;pod的探针&lt;/h1&gt;

&lt;p&gt;在学pod探针之前得先知道pod生命周期&lt;/p&gt;

&lt;h2 id=&quot;pod生命周期&quot;&gt;pod生命周期&lt;/h2&gt;

&lt;p&gt;首先说一下pod的生命周期：pending，running，succeeded，faild，unknown.&lt;/p&gt;

&lt;p&gt;挂起（Pending）：Pod 已被 Kubernetes 系统接受，但有一个或者多个容器镜像尚未创建。等待时间包括调度 Pod 的时间和通过网络下载镜像的时间，这可能需要花点时间。&lt;/p&gt;

&lt;p&gt;运行中（Running）：该 Pod 已经绑定到了一个节点上，Pod 中所有的容器都已被创建。至少有一个容器正在运行，或者正处于启动或重启状态。&lt;/p&gt;

&lt;p&gt;成功（Succeeded）：Pod 中的所有容器都被成功终止，并且不会再重启。&lt;/p&gt;

&lt;p&gt;失败（Failed）：Pod 中的所有容器都已终止了，并且至少有一个容器是因为失败终止。也就是说，容器以非0状态退出或者被系统终止。&lt;/p&gt;

&lt;p&gt;未知（Unknown）：因为某些原因无法取得 Pod 的状态，通常是因为与 Pod 所在主机通信失败。&lt;/p&gt;

&lt;h2 id=&quot;三种探针&quot;&gt;三种探针&lt;/h2&gt;
&lt;p&gt;存活探针/探测器（liveness）：看容器什么时候要重启.&lt;/p&gt;

&lt;p&gt;就绪探针/探测器（rediness）：看一组容器的pod是否准备好接受流量.&lt;/p&gt;

&lt;p&gt;启动探测器：看容器什么时候重启的.&lt;/p&gt;

&lt;p&gt;每次探测都将获得以下三种结果之一：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;成功：容器通过了诊断。&lt;/li&gt;
  &lt;li&gt;失败：容器未通过诊断。&lt;/li&gt;
  &lt;li&gt;未知：诊断失败，因此不会采取任何行动。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;存活探针的3种使用方式&quot;&gt;存活探针的3种使用方式：&lt;/h3&gt;
&lt;p&gt;1）.使用存活命令查看：cat /tmp/health，是0就健康，非0就不健康，就会被杀死重启。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;livenessProbe:
exec:
  command:
    &lt;ul&gt;
      &lt;li&gt;cat&lt;/li&gt;
      &lt;li&gt;/tmp/healthy
initialDelaySeconds: 5&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;periodSeconds: 5&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;periodSeconds 规定kubelet要每隔5秒执行一次liveness probe。&lt;/p&gt;

&lt;p&gt;initialDelaySeconds 告诉kubelet在第一次执行probe之前要的等待5秒钟。&lt;/p&gt;

&lt;p&gt;2).http get请求：[200,400)之间就是存活。&lt;/p&gt;

&lt;p&gt;livenessProbe:
    httpGet:
      path: /healthz
      port: 8080
      httpHeaders:
        - name: X-Custom-Header
          value: Awesome
    initialDelaySeconds: 3
    periodSeconds: 3&lt;/p&gt;

&lt;p&gt;ivenessProbe 指定kubelet需要每隔3秒执行一次liveness probe。&lt;/p&gt;

&lt;p&gt;initialDelaySeconds 指定kubelet在该执行第一次探测之前需要等待3秒钟。&lt;/p&gt;

&lt;p&gt;3）tcp套接字：能连上就是存活的。&lt;/p&gt;

&lt;p&gt;readinessProbe:
tcpSocket:
	port: 8080
initialDelaySeconds: 5
periodSeconds: 10
livenessProbe:
tcpSocket:
	port: 8080
initialDelaySeconds: 15
periodSeconds: 20&lt;/p&gt;

&lt;p&gt;同时使用了readiness和liveness probe。 容器启动后5秒钟，kubelet将发送第一个readiness probe。 这将尝试连接到端口8080上的goproxy容器。如果探测成功，则该pod将被标记为就绪。Kubelet将每隔10秒钟执行一次该检查。&lt;/p&gt;

&lt;p&gt;除了readiness probe之外，该配置还包括liveness probe。 容器启动15秒后，kubelet将运行第一个liveness probe。 就像readiness probe一样，这将尝试连接到goproxy容器上的8080端口。如果liveness probe失败，容器将重新启动。&lt;/p&gt;
&lt;h3 id=&quot;启动探测器&quot;&gt;启动探测器&lt;/h3&gt;
&lt;p&gt;有时候，会有一些现有的应用程序在启动时需要较多的初始化时间。要不影响对引起探测死锁的快速响应，这种情况下，设置存活探测参数是要技巧的。技巧就是使用一个命令来设置启动探测，针对HTTP 或者 TCP 检测，可以通过设置 failureThreshold * periodSeconds 参数来保证有足够长的时间应对糟糕情况下的启动时间。&lt;/p&gt;
&lt;h2 id=&quot;怎么看pod中的容器是否健康&quot;&gt;怎么看Pod中的容器是否健康&lt;/h2&gt;
&lt;p&gt;status 属性里面有一个conditions字段记录了容器状态，其中 ：&lt;/p&gt;

&lt;p&gt;type: Ready=True 表示Pod已经准备就绪，切已经加入了Service的负载均衡当中&lt;/p&gt;

&lt;p&gt;type: ContainersReady=True表示所有Pod中所有容器都通过了健康检查（如有），并全部准备就绪&lt;/p&gt;
&lt;h2 id=&quot;k8s是怎么进行服务注册的&quot;&gt;k8s是怎么进行服务注册的&lt;/h2&gt;
&lt;p&gt;Pod启动后会加载当前环境所有Service信息，以便不同Pod根据Service名进行通信&lt;/p&gt;

&lt;h2 id=&quot;各层负载均衡&quot;&gt;各层负载均衡&lt;/h2&gt;
&lt;p&gt;二层负载均衡：基于MAC地址的二层负载均衡。&lt;/p&gt;

&lt;p&gt;三层负载均衡：基于IP地址的负载均衡。&lt;/p&gt;

&lt;p&gt;四层负载均衡：基于IP+端口的负载均衡。&lt;/p&gt;

&lt;p&gt;七层负载均衡：基于URL等应用层信息的负载均衡。&lt;/p&gt;

&lt;p&gt;上面四层服务发现讲的主要是k8s原生的kube-proxy方式。K8s关于服务的暴露主要是通过NodePort方式，通过绑定minion主机的某个端口，然后进行pod的请求转发和负载均衡，但这种方式有下面的缺陷：&lt;/p&gt;

&lt;p&gt;Service可能有很多个，如果每个都绑定一个node主机端口的话，主机需要开放外围的端口进行服务调用，管理混乱。无法应用很多公司要求的防火墙规则。
理想的方式是通过一个外部的负载均衡器，绑定固定的端口，比如80，然后根据域名或者服务名向后面的Service ip转发，Nginx很好的解决了这个需求，但问题是如果有的心得服务加入，如何去修改Nginx的配置，并且加载这些配置？Kubernetes给出的方案就是Ingress。这是一个基于7层的方案。&lt;/p&gt;
&lt;h2 id=&quot;说说你对容器的理解&quot;&gt;说说你对容器的理解&lt;/h2&gt;
&lt;p&gt;容器的理解：&lt;/p&gt;

&lt;p&gt;应用部署在linux系统上和部署在容器上有什么区别？&lt;/p&gt;
&lt;h2 id=&quot;如何对容器的限额&quot;&gt;如何对容器的限额&lt;/h2&gt;
&lt;p&gt;比如说限制容器最大的CPU为16G，如何配置&lt;/p&gt;
&lt;h2 id=&quot;k8s-的多主之间如何工作&quot;&gt;k8s 的多主之间如何工作&lt;/h2&gt;

&lt;h2 id=&quot;k8s-一台节点unknown会是什么原因&quot;&gt;k8s 一台节点unknown会是什么原因&lt;/h2&gt;

&lt;h2 id=&quot;docker运行一个容器之后无缘无故退出会是什么原因&quot;&gt;docker运行一个容器之后无缘无故退出会是什么原因&lt;/h2&gt;

&lt;h2 id=&quot;有一个容器应用一直自动重启你如何去处理&quot;&gt;有一个容器（应用）一直自动重启，你如何去处理&lt;/h2&gt;
</description>
        <pubDate>Thu, 25 Jun 2020 10:03:00 +0800</pubDate>
        <link>http://192.168.11.32:4000/2020/06/25/ks8-thinks/</link>
        <guid isPermaLink="true">http://192.168.11.32:4000/2020/06/25/ks8-thinks/</guid>
        
        <category>k8s</category>
        
        
      </item>
    
  </channel>
</rss>
