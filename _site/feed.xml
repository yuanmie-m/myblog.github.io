<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>yuanmie</title>
    <description>疯狂的学习.</description>
    <link>http://192.168.11.32:4000/</link>
    <atom:link href="http://192.168.11.32:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sat, 27 Jun 2020 14:48:39 +0800</pubDate>
    <lastBuildDate>Sat, 27 Jun 2020 14:48:39 +0800</lastBuildDate>
    <generator>Jekyll v4.1.1</generator>
    
      <item>
        <title>高可用解决方案</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;“高可用 on1. ”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;高可用&quot;&gt;高可用&lt;/h1&gt;

</description>
        <pubDate>Sat, 27 Jun 2020 00:00:00 +0800</pubDate>
        <link>http://192.168.11.32:4000/linux/2020/06/27/%E9%AB%98%E5%8F%AF%E7%94%A8/</link>
        <guid isPermaLink="true">http://192.168.11.32:4000/linux/2020/06/27/%E9%AB%98%E5%8F%AF%E7%94%A8/</guid>
        
        <category>高可用</category>
        
        
        <category>Linux</category>
        
      </item>
    
      <item>
        <title>zabbix</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;“zabbix on1. ”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;zabbix，是什么。&lt;/p&gt;

&lt;h1 id=&quot;zabbix&quot;&gt;zabbix&lt;/h1&gt;

</description>
        <pubDate>Sat, 27 Jun 2020 00:00:00 +0800</pubDate>
        <link>http://192.168.11.32:4000/linux/2020/06/27/zabbix/</link>
        <guid isPermaLink="true">http://192.168.11.32:4000/linux/2020/06/27/zabbix/</guid>
        
        <category>zabbix</category>
        
        
        <category>Linux</category>
        
      </item>
    
      <item>
        <title>nginx</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;nginx on1. ”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;nginx，搞懂反向代理和负载均衡！&lt;/p&gt;

&lt;h1 id=&quot;反向代理&quot;&gt;反向代理&lt;/h1&gt;

&lt;p&gt;反向代理怎么做？具体如何实现？&lt;/p&gt;

&lt;h1 id=&quot;负载均衡&quot;&gt;负载均衡&lt;/h1&gt;

&lt;p&gt;负载均衡怎么做？具体怎么实现？&lt;/p&gt;
</description>
        <pubDate>Sat, 27 Jun 2020 00:00:00 +0800</pubDate>
        <link>http://192.168.11.32:4000/linux/2020/06/27/nginx/</link>
        <guid isPermaLink="true">http://192.168.11.32:4000/linux/2020/06/27/nginx/</guid>
        
        <category>nginx</category>
        
        
        <category>Linux</category>
        
      </item>
    
      <item>
        <title>jenkins</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;jenkins on1. ”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;jenkins&lt;/p&gt;

&lt;h1 id=&quot;jenkins&quot;&gt;jenkins&lt;/h1&gt;

</description>
        <pubDate>Sat, 27 Jun 2020 00:00:00 +0800</pubDate>
        <link>http://192.168.11.32:4000/linux/2020/06/27/jenkins/</link>
        <guid isPermaLink="true">http://192.168.11.32:4000/linux/2020/06/27/jenkins/</guid>
        
        <category>jenkins</category>
        
        
        <category>Linux</category>
        
      </item>
    
      <item>
        <title>docker入门</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;“docker on1. ”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;docker&quot;&gt;docker&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;images&lt;/code&gt;    List images                                   # 列出系统当前镜像&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ps&lt;/code&gt;        List containers                               # 列出容器列表&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;info&lt;/code&gt;      Display system-wide information               # 显示系统相关信息&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;inspect&lt;/code&gt;   Return low-level information on a container   # 查看容器详细信息&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kill&lt;/code&gt;      Kill a running container                      # kill 指定 docker 容器&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;load&lt;/code&gt;      Load an image from a tar archive              # 从一个 tar 包中加载一个镜像[对应 save]&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;save&lt;/code&gt;      Save an image to a tar archive                # 保存一个镜像为一个 tar 包[对应 load]&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;login&lt;/code&gt;     Register or Login to the docker registry server &lt;br /&gt;
              # 注册或者登陆一个 docker 源服务器&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tag&lt;/code&gt;       Tag an image into a repository                # 给源中镜像打标签&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pull&lt;/code&gt;      Pull an image or a repository from the docker registry server
              # 从docker镜像源服务器拉取指定镜像或者库镜像&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;push&lt;/code&gt;      Push an image or a repository to the docker registry server
              # 推送指定镜像或者库镜像至docker源服务器&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rm&lt;/code&gt;        Remove one or more containers                 # 移除一个或者多个容器&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rmi&lt;/code&gt;       Remove one or more images               &lt;br /&gt;
              # 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;log&lt;/code&gt;       Fetch the logs of a container                 # 输出当前容器日志信息&lt;/p&gt;

&lt;p&gt;例如：查看指定时间后的日志，只显示最后100行：
docker logs -f -t –since=”2020-06-27” –tail=100 CONTAINER_ID&lt;/p&gt;

&lt;p&gt;查看最近30分钟的日志：docker logs –since 30m CONTAINER_ID&lt;/p&gt;

&lt;p&gt;查看某时间之后的日志：logs -t –since=”2020-06-27T13:23:37” CONTAINER_ID&lt;/p&gt;

&lt;p&gt;查看某时间段日志：docker logs -t –since=”2020-06-26T13:23:37” –until “2020-06-27T12:23:37” CONTAINER_ID&lt;/p&gt;
</description>
        <pubDate>Sat, 27 Jun 2020 00:00:00 +0800</pubDate>
        <link>http://192.168.11.32:4000/linux/2020/06/27/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</link>
        <guid isPermaLink="true">http://192.168.11.32:4000/linux/2020/06/27/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</guid>
        
        <category>docker</category>
        
        
        <category>Linux</category>
        
      </item>
    
      <item>
        <title>docker累积</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;“docker on2. ”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;docker的一些累积，持续更新。&lt;/p&gt;

&lt;h1 id=&quot;docker的安装&quot;&gt;docker的安装&lt;/h1&gt;

&lt;p&gt;安装方法有很多种，一种简单的方法：&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl &lt;span class=&quot;nt&quot;&gt;-fsSL&lt;/span&gt; https://get.docker.com | bash &lt;span class=&quot;nt&quot;&gt;-s&lt;/span&gt; docker &lt;span class=&quot;nt&quot;&gt;--mirror&lt;/span&gt; Aliyun。快速！
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h1 id=&quot;docker的默认&quot;&gt;docker的默认&lt;/h1&gt;

&lt;p&gt;docker有哪些默认的配置？记性不好了，记录记录，以便忘记的时候拿来看。&lt;/p&gt;

&lt;h2 id=&quot;docker默认存储位置&quot;&gt;docker默认存储位置&lt;/h2&gt;
&lt;p&gt;Docker默认存储位置在/var/lib/docker&lt;/p&gt;

&lt;h2 id=&quot;docker默认配置文件&quot;&gt;docker默认配置文件&lt;/h2&gt;
&lt;p&gt;ubuntu 中的位置是：/etc/default/docker&lt;/p&gt;

&lt;p&gt;centos 中的位置是：/etc/sysconfig/docker&lt;/p&gt;

&lt;h1 id=&quot;docker-compose&quot;&gt;docker compose&lt;/h1&gt;
</description>
        <pubDate>Sat, 27 Jun 2020 00:00:00 +0800</pubDate>
        <link>http://192.168.11.32:4000/linux/2020/06/27/dockerknowledge/</link>
        <guid isPermaLink="true">http://192.168.11.32:4000/linux/2020/06/27/dockerknowledge/</guid>
        
        <category>docker</category>
        
        
        <category>Linux</category>
        
      </item>
    
      <item>
        <title>ELK</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;“ELK on1. ”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;ELK，是什么。&lt;/p&gt;

&lt;h1 id=&quot;elk&quot;&gt;ELK&lt;/h1&gt;

</description>
        <pubDate>Sat, 27 Jun 2020 00:00:00 +0800</pubDate>
        <link>http://192.168.11.32:4000/linux/2020/06/27/ELK/</link>
        <guid isPermaLink="true">http://192.168.11.32:4000/linux/2020/06/27/ELK/</guid>
        
        <category>ELK</category>
        
        
        <category>Linux</category>
        
      </item>
    
      <item>
        <title>jekyll之_posts</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;“no3. ”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;首先感谢大佬&lt;a href=&quot;https://github.com/Huxpro/huxpro.github.io&quot;&gt;Huxpro&lt;/a&gt;做的模板，非常喜欢，风格也简约，blog的管理也非常方便。&lt;/p&gt;

&lt;p&gt;先知道安装，可以参考我的另一篇，把坑都填好了。运行起来之后，在看jekyll的目录结构，搞清楚每一个文档是干什么的。&lt;/p&gt;

&lt;h2 id=&quot;_posts文件&quot;&gt;_posts文件&lt;/h2&gt;

&lt;p&gt;这里放的就是你的文章了。文件格式很重要，必须符合：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;YEAR-MONTH-DAY-TITLE.MARKUP&lt;/code&gt;。The permalinks可以在文章中自己定制，但是数据和标记语言都是根据文件名来确定的。&lt;/p&gt;

&lt;h2 id=&quot;内容格式及修饰&quot;&gt;内容格式及修饰&lt;/h2&gt;

&lt;p&gt;分为2部分，yaml头文件和内容&lt;/p&gt;

&lt;p&gt;1.yaml头文件的格式，这个比较简单&lt;/p&gt;

&lt;p&gt;2.具体内容&lt;/p&gt;

&lt;p&gt;拿一篇文章来说，举个例子体现出用了什么东西。&lt;/p&gt;

&lt;p&gt;最喜欢的一部修真小说，从初中接触到大学毕业一直看，看了7遍，可以说里面的每一个场景都记得，就拿里面的一些东西来举例，顺便也做个例子。&lt;/p&gt;

&lt;p&gt;标题格式：### 内容&lt;/p&gt;

&lt;h3 id=&quot;隔一行和不隔一行的区别&quot;&gt;隔一行和不隔一行的区别：&lt;/h3&gt;

&lt;p&gt;玉符现，天地乱，虚无出，七界哭。逆天子，万灭徒，相逢日，七界无。&lt;/p&gt;

&lt;p&gt;夜月斩，夜月斩，太玄山上，黄河之畔。得之无意间，几许回忆在心田。
太玄山，天地间，修真几许为神仙？少年心，贪尘缘，狂剑纵横为红颜！&lt;/p&gt;

&lt;h3 id=&quot;链接格式&quot;&gt;链接格式&lt;/h3&gt;

&lt;p&gt;内容[]+()链接，在英文键盘下输入&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://baike.baidu.com/item/%E4%B8%83%E7%95%8C%E4%BC%A0%E8%AF%B4%E6%AD%A3%E4%BC%A0&quot;&gt;七界传说-百度百科&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;列表格式&quot;&gt;列表格式&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;述不清，道不明，世间最烦是感情！&lt;/li&gt;
  &lt;li&gt;见着怨，不见念，最难割舍最难断，是缘是孽，如何分辨？&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;字体格式&quot;&gt;字体格式&lt;/h3&gt;

&lt;p&gt;字体加颜色：
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;百世轮回，千世转变，沧海桑田，我心不变。&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;字体加粗：
&lt;strong&gt;如此星辰如此月，结伴携手月下行。&lt;/strong&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 25 Jun 2020 18:16:00 +0800</pubDate>
        <link>http://192.168.11.32:4000/2020/06/25/jekyll+github-post/</link>
        <guid isPermaLink="true">http://192.168.11.32:4000/2020/06/25/jekyll+github-post/</guid>
        
        <category>jekyll</category>
        
        
      </item>
    
      <item>
        <title>k8s一些思考</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;“k8s on3. ”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;记录k8s的问题&lt;/p&gt;

&lt;h1 id=&quot;证书&quot;&gt;证书&lt;/h1&gt;
&lt;p&gt;一个k8s集群，最少有6套证书。&lt;/p&gt;

&lt;p&gt;ca根证书，etcd，client，apiserver，kubelet，kube-proxy&lt;/p&gt;

&lt;p&gt;证书签发插件有：cfssl，openssl等等&lt;/p&gt;

&lt;h1 id=&quot;pod的探针&quot;&gt;pod的探针&lt;/h1&gt;

&lt;p&gt;在学pod探针之前得先知道pod生命周期&lt;/p&gt;

&lt;h2 id=&quot;pod生命周期&quot;&gt;pod生命周期&lt;/h2&gt;

&lt;p&gt;首先说一下pod的生命周期：pending，running，succeeded，faild，unknown.&lt;/p&gt;

&lt;p&gt;挂起（Pending）：Pod 已被 Kubernetes 系统接受，但有一个或者多个容器镜像尚未创建。等待时间包括调度 Pod 的时间和通过网络下载镜像的时间，这可能需要花点时间。&lt;/p&gt;

&lt;p&gt;运行中（Running）：该 Pod 已经绑定到了一个节点上，Pod 中所有的容器都已被创建。至少有一个容器正在运行，或者正处于启动或重启状态。&lt;/p&gt;

&lt;p&gt;成功（Succeeded）：Pod 中的所有容器都被成功终止，并且不会再重启。&lt;/p&gt;

&lt;p&gt;失败（Failed）：Pod 中的所有容器都已终止了，并且至少有一个容器是因为失败终止。也就是说，容器以非0状态退出或者被系统终止。&lt;/p&gt;

&lt;p&gt;未知（Unknown）：因为某些原因无法取得 Pod 的状态，通常是因为与 Pod 所在主机通信失败。&lt;/p&gt;

&lt;h2 id=&quot;三种探针&quot;&gt;三种探针&lt;/h2&gt;
&lt;p&gt;存活探针/探测器（liveness）：看容器什么时候要重启.&lt;/p&gt;

&lt;p&gt;就绪探针/探测器（rediness）：看一组容器的pod是否准备好接受流量.&lt;/p&gt;

&lt;p&gt;启动探测器：看容器什么时候重启的.&lt;/p&gt;

&lt;p&gt;每次探测都将获得以下三种结果之一：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;成功：容器通过了诊断。&lt;/li&gt;
  &lt;li&gt;失败：容器未通过诊断。&lt;/li&gt;
  &lt;li&gt;未知：诊断失败，因此不会采取任何行动。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;存活探针的3种使用方式&quot;&gt;存活探针的3种使用方式：&lt;/h3&gt;
&lt;p&gt;1）.使用存活命令查看：cat /tmp/health，是0就健康，非0就不健康，就会被杀死重启。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;livenessProbe:
exec:
  command:
    &lt;ul&gt;
      &lt;li&gt;cat&lt;/li&gt;
      &lt;li&gt;/tmp/healthy
initialDelaySeconds: 5&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;periodSeconds: 5&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;periodSeconds 规定kubelet要每隔5秒执行一次liveness probe。&lt;/p&gt;

&lt;p&gt;initialDelaySeconds 告诉kubelet在第一次执行probe之前要的等待5秒钟。&lt;/p&gt;

&lt;p&gt;2).http get请求：[200,400)之间就是存活。&lt;/p&gt;

&lt;p&gt;livenessProbe:
    httpGet:
      path: /healthz
      port: 8080
      httpHeaders:
        - name: X-Custom-Header
          value: Awesome
    initialDelaySeconds: 3
    periodSeconds: 3&lt;/p&gt;

&lt;p&gt;ivenessProbe 指定kubelet需要每隔3秒执行一次liveness probe。&lt;/p&gt;

&lt;p&gt;initialDelaySeconds 指定kubelet在该执行第一次探测之前需要等待3秒钟。&lt;/p&gt;

&lt;p&gt;3）tcp套接字：能连上就是存活的。&lt;/p&gt;

&lt;p&gt;readinessProbe:
tcpSocket:
	port: 8080
initialDelaySeconds: 5
periodSeconds: 10
livenessProbe:
tcpSocket:
	port: 8080
initialDelaySeconds: 15
periodSeconds: 20&lt;/p&gt;

&lt;p&gt;同时使用了readiness和liveness probe。 容器启动后5秒钟，kubelet将发送第一个readiness probe。 这将尝试连接到端口8080上的goproxy容器。如果探测成功，则该pod将被标记为就绪。Kubelet将每隔10秒钟执行一次该检查。&lt;/p&gt;

&lt;p&gt;除了readiness probe之外，该配置还包括liveness probe。 容器启动15秒后，kubelet将运行第一个liveness probe。 就像readiness probe一样，这将尝试连接到goproxy容器上的8080端口。如果liveness probe失败，容器将重新启动。&lt;/p&gt;
&lt;h3 id=&quot;启动探测器&quot;&gt;启动探测器&lt;/h3&gt;
&lt;p&gt;有时候，会有一些现有的应用程序在启动时需要较多的初始化时间。要不影响对引起探测死锁的快速响应，这种情况下，设置存活探测参数是要技巧的。技巧就是使用一个命令来设置启动探测，针对HTTP 或者 TCP 检测，可以通过设置 failureThreshold * periodSeconds 参数来保证有足够长的时间应对糟糕情况下的启动时间。&lt;/p&gt;
&lt;h2 id=&quot;怎么看pod中的容器是否健康&quot;&gt;怎么看Pod中的容器是否健康&lt;/h2&gt;
&lt;p&gt;status 属性里面有一个conditions字段记录了容器状态，其中 ：&lt;/p&gt;

&lt;p&gt;type: Ready=True 表示Pod已经准备就绪，切已经加入了Service的负载均衡当中&lt;/p&gt;

&lt;p&gt;type: ContainersReady=True表示所有Pod中所有容器都通过了健康检查（如有），并全部准备就绪&lt;/p&gt;
&lt;h2 id=&quot;k8s是怎么进行服务注册的&quot;&gt;k8s是怎么进行服务注册的&lt;/h2&gt;
&lt;p&gt;Pod启动后会加载当前环境所有Service信息，以便不同Pod根据Service名进行通信&lt;/p&gt;

&lt;h2 id=&quot;各层负载均衡&quot;&gt;各层负载均衡&lt;/h2&gt;
&lt;p&gt;二层负载均衡：基于MAC地址的二层负载均衡。&lt;/p&gt;

&lt;p&gt;三层负载均衡：基于IP地址的负载均衡。&lt;/p&gt;

&lt;p&gt;四层负载均衡：基于IP+端口的负载均衡。&lt;/p&gt;

&lt;p&gt;七层负载均衡：基于URL等应用层信息的负载均衡。&lt;/p&gt;

&lt;p&gt;上面四层服务发现讲的主要是k8s原生的kube-proxy方式。K8s关于服务的暴露主要是通过NodePort方式，通过绑定minion主机的某个端口，然后进行pod的请求转发和负载均衡，但这种方式有下面的缺陷：&lt;/p&gt;

&lt;p&gt;Service可能有很多个，如果每个都绑定一个node主机端口的话，主机需要开放外围的端口进行服务调用，管理混乱。无法应用很多公司要求的防火墙规则。
理想的方式是通过一个外部的负载均衡器，绑定固定的端口，比如80，然后根据域名或者服务名向后面的Service ip转发，Nginx很好的解决了这个需求，但问题是如果有的心得服务加入，如何去修改Nginx的配置，并且加载这些配置？Kubernetes给出的方案就是Ingress。这是一个基于7层的方案。&lt;/p&gt;
&lt;h2 id=&quot;说说你对容器的理解&quot;&gt;说说你对容器的理解&lt;/h2&gt;
&lt;p&gt;容器的理解：&lt;/p&gt;

&lt;p&gt;应用部署在linux系统上和部署在容器上有什么区别？&lt;/p&gt;
&lt;h2 id=&quot;如何对容器的限额&quot;&gt;如何对容器的限额&lt;/h2&gt;
&lt;p&gt;比如说限制容器最大的CPU为16G，如何配置&lt;/p&gt;
&lt;h2 id=&quot;k8s-的多主之间如何工作&quot;&gt;k8s 的多主之间如何工作&lt;/h2&gt;

&lt;h2 id=&quot;k8s-一台节点unknown会是什么原因&quot;&gt;k8s 一台节点unknown会是什么原因&lt;/h2&gt;

&lt;h2 id=&quot;docker运行一个容器之后无缘无故退出会是什么原因&quot;&gt;docker运行一个容器之后无缘无故退出会是什么原因&lt;/h2&gt;

&lt;h2 id=&quot;有一个容器应用一直自动重启你如何去处理&quot;&gt;有一个容器（应用）一直自动重启，你如何去处理&lt;/h2&gt;
</description>
        <pubDate>Thu, 25 Jun 2020 10:03:00 +0800</pubDate>
        <link>http://192.168.11.32:4000/2020/06/25/ks8-thinks/</link>
        <guid isPermaLink="true">http://192.168.11.32:4000/2020/06/25/ks8-thinks/</guid>
        
        <category>k8s</category>
        
        
      </item>
    
      <item>
        <title>prometheus--问题</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;“prometheus on2. ”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;每学一样东西你都该问自己一些问题，学会问问题也是一种自我提升方式。&lt;/p&gt;

&lt;h1 id=&quot;prometheus是如何存储数据的&quot;&gt;Prometheus是如何存储数据的？&lt;/h1&gt;
&lt;p&gt;prometheus采用time-series(时间序列)方式，存储在本地硬盘。&lt;/p&gt;

&lt;p&gt;prometheus本地T-S数据库以每2小时间隔来分block(块)存储，每个块又分为多个chunk文件，chunk文件用来存放采集的数据的T-S（time-series）数据，metadata和索引文件；&lt;/p&gt;

&lt;p&gt;index文件是对metrics和labels进行索引之后存储在chunk中，chunk是作为基本存储单位，index和metadata作为子集；&lt;/p&gt;

&lt;p&gt;prometheus平时采集到的数据先存放在内存之中，对内存消耗大，以缓存的方式可以加快搜索和访问；&lt;/p&gt;

&lt;p&gt;在prometheus宕机时，prometheus有一种保护机制WAL，可以将数据定期存入硬盘中以chunk来表示，在重新启动时，可以恢复进内存当中。&lt;/p&gt;

&lt;p&gt;当通过API删除序列时，删除的记录存储在单独的tombstone文件中(而不是立即从块文件中删除数据)。&lt;/p&gt;

&lt;p&gt;注意：&lt;/p&gt;

&lt;p&gt;这里需要注意的是，本地存储的一个限制是它不是集群的或可复制的。因此，在磁盘或节点宕机时，它也不是任意可伸缩或持久的，对于磁盘可用性，建议使用RAID、备份快照、容量规划等，以提高持久性。应该通过适当的存储持久性和计划在本地存储中存储多年的数据。&lt;/p&gt;

&lt;h1 id=&quot;prometheus集成的服务发现功能&quot;&gt;prometheus集成的服务发现功能？&lt;/h1&gt;

&lt;p&gt;之前有说，看prometheus架构这一篇&lt;/p&gt;

&lt;h1 id=&quot;prometheus数据采集的方式&quot;&gt;Prometheus数据采集的方式？&lt;/h1&gt;
&lt;p&gt;prometheus客户端主要由2种数据采集的方式：&lt;/p&gt;

&lt;p&gt;pull：主动拉取形式&lt;/p&gt;

&lt;p&gt;push：被动推送的形式&lt;/p&gt;

&lt;p&gt;pull：指的是客户端（被监控主机）先安装各类已有的exporters在系统上，exporters以守护进程的模式运行，并开始采集数据，exporters本身也是一个http_server，可以对http请求作出响应，并返回K/V数据，也就是metrics。prometheus通过用pull的方式（HTTP_GET）去访问每个节点上的exporter并采集回需要的数据。&lt;/p&gt;

&lt;p&gt;push：指的是客户端（或服务端）安装官方的pushgateway插件，然后通过我们自行编写的各种脚本，将监控数据组织成K/V的形式（metrics形式）发送给pushgateway，而后pushgateway再推送给prometheus，这里需要注意的是pushgateway不一定要安装在被监控端，也可以安装在服务端，甚至是一台不相关的主机上，换句话来说，它只是一个中间转发的媒介。&lt;/p&gt;

&lt;h1 id=&quot;prometheus如何实现告警&quot;&gt;Prometheus如何实现告警？&lt;/h1&gt;
&lt;p&gt;使用alertmanager&lt;/p&gt;

&lt;h1 id=&quot;什么是metrics&quot;&gt;什么是metrics？&lt;/h1&gt;
&lt;p&gt;一组K/V数据就是metrics，总体上来说metrics是对采集过来的数据的一种统称，并非一个具体的数值或指标。&lt;/p&gt;

&lt;h1 id=&quot;metrics的类型&quot;&gt;metrics的类型？&lt;/h1&gt;
&lt;p&gt;Gauges：最简单的度量指标，只有一个简单的返回值，或者叫做瞬时状态，比如要采集硬盘容量或内存使用率，就可以用gauges的metrics格式来度量。因为硬盘和内存是随着时间推移不断地变化，没有规则的变化，当前是多少，采集回来的就是多少，既不能肯定是一直持续增长，也不能肯定是一直降低，是多少就是多少，这种就是Gauges使用类型的代表。&lt;/p&gt;

&lt;p&gt;Counters：Counters就是计数器，从数据量0开始累积计算，理想状态下，只能是永远的增长，绝不会出现降低，比如用户的访问量采样数据，我们的产品被用户访问了一次就是1，过了10分钟后积累到100，过了1天就累积到20000。&lt;/p&gt;

&lt;p&gt;Histograms：柱状图，用于观察结果采样，分组及统计，如：请求持续时间，响应大小。其主要用于表示一段时间内对数据的采样，并能够对其指定区间及总数进行统计。根据统计区间计算。&lt;/p&gt;

&lt;p&gt;Summary：类似Histogram，用于表示一段时间内数据采样结果，其直接存储quantile数据，而不是根据统计区间计算出来的。不需要计算，直接存储结果。&lt;/p&gt;

&lt;h1 id=&quot;什么是node-exporter&quot;&gt;什么是node-exporter&lt;/h1&gt;
&lt;p&gt;Prometheus为了支持各种中间件以及第三方的监控提供了exporter，大家可以把它理解成监控适配器，将不同指标类型和格式的数据统一转化为Prometheus能够识别的指标类型。&lt;/p&gt;

&lt;p&gt;譬如Node exporter主要通过读取Linux的/proc以及/sys目录下的系统文件获取操作系统运行状态，reids exporter通过Reids命令行获取指标，mysql exporter通过读取数据库监控表获取MySQL的性能数据。他们将这些异构的数据转化为标准的Prometheus格式，并提供HTTP查询接口。&lt;/p&gt;

&lt;h1 id=&quot;什么是pushgateway&quot;&gt;什么是pushgateway？&lt;/h1&gt;
&lt;p&gt;通过node-exporter可以收集到各种服务器的相关性指标，但是并没有办法满足我们的定制化需求，比如需要监控某个进程数，某个进程打开的文件数，某个进程消耗的内存等等，这就需要一个定制化的监控项，类似于zabbix的自定义监控项是一个道理。&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;以上内容&lt;a href=&quot;https://www.cnblogs.com/linuxk/p/12017580.html&quot;&gt;原文&lt;/a&gt;
—&lt;/p&gt;
</description>
        <pubDate>Thu, 25 Jun 2020 10:03:00 +0800</pubDate>
        <link>http://192.168.11.32:4000/2020/06/25/promethus-thinks/</link>
        <guid isPermaLink="true">http://192.168.11.32:4000/2020/06/25/promethus-thinks/</guid>
        
        <category>prometheus</category>
        
        
      </item>
    
  </channel>
</rss>
